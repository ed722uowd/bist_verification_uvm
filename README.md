# BIST Design Verification Project using UVM & C++


## ğŸ“Œ Overview

This project implements and verifies a **Built-In Self Test (BIST)** architecture using **SystemVerilog** and the **Universal Verification Methodology (UVM)** framework. A **Design Under Test (DUT)** generates psuedo random patterns and feeds it into a Circuit (compatator) and generates a signature using a MISR. The outputs are validated against **golden reference values** generated using C++.

---

## ğŸ§¾ Verilog Design Description

The Verilog design consists of a BIST module that outputs signatures. These signatures are meant to be compared against precomputed expected values (golden values) to verify the correctness of the logic.

The design simulates how a self-testing system can compress data using techniques like LFSR or MISR and verify outputs internally without needing external test equipment.

The design consists of an LFSR that generates pseudo random patterns. The patterns are then fed to a comparator the compares the lower bits with the upper bits. The out put generates a 3 bit which tells us whether the the comparison results in equality, lesser than or greater than. This result is fed to the MISR to 3 of the eight inputs (the remainiing 5 inputs are set to 0).

The entire design runs for 10 clock cycles to generate a unique signature.

## Design Modules

The design is composed of 4 modules:

#### Module BIST

The highest module in the hierarchy that instantiates the modules LFSR_PRPG, comparator, MISR_compactor.

#### Module LFSR_PRPG

Generates pseudo random patterns for the comparator (CUT). A seed is loaded into the LFSR. This uses a seed of 11111111 (Changes to the seed can be made in the .cpp file and the Test bech). The LFSR is based of the primitive polynomial $phi(x) = x^8+x^6+x^5+x+1$.

Modules **dff** and **selector** are instantiated in this module.

#### Module dff

This is a D-Flip-Flop instantiated in the modules **LFSR_PRPG** and **MISR_compactor**.

#### Module selector

A mux that taht is instantiated in **LFSR_PRPG** and **MISR_compactor** before the DFF in order to load the seed values initially at the first low of the clock cycle. If the selecct line is set to 1 the seed value is loaded, else the DFFs are connected to each other.

#### Module comparator

This is the Circuit Under Test and compares the Most significant 4 bits with the least significat 4 bits of the pattern generated by the LFSR. Is the 4 MSB are greater then the output is 010, if the LSB is greater then the result is 100, if they are equal the resultant output is 000.

#### Module MISR_compactor

This circuit generates a signature using the inputs from the Circuit under test (CUT). A seed value is initially loaded 00000000. The MISR is based off the primitive polynomial $phi(x) = x^8+x^6+x^5+x+1$ (same as the PSRG).

---

## ğŸ”— EDA Playground Link

ğŸ‘‰ [Run the UVM simulation on EDA Playground](https://www.edaplayground.com/x/7hUK)  

---

## âš™ï¸ C++ Golden Signature Generator

A separate C++ program is used to generate golden reference values based on the same logic applied in the DUT. These golden values are saved to a file or printed to the console, which are later used in the UVM testbench for comparison.

### ğŸ“‚ C++ File Location


model/golden_val.cpp



### â–¶ï¸ How to Run the C++ Code

From the project root directory:

```bash
cd .../bist_verification_project_model
make run
````
or

```
You can copy the code from golden_val.cpp and run it on an online compiler.
Copy the signature and paste it in a .txt file and label it as 'golden_val_file.txt'.
````

This will:

* Print the golden signature to the terminal.
* Save the signature to a file named `golden_val_file.txt`.

---

## ğŸ“¥ Using Golden Values in Simulation

Once the golden values are generated:

1. Open the generated `golden_val_file.txt` or copy the printed output from the terminal.
2. Go to the [EDA Playground link](https://www.edaplayground.com/some-link).
3. Paste the golden values into the text file section (`golden_val_file.txt`) provided in the simulation setup.
4. Make sure youâ€™ve selected a tool like **Questa** or **VCS**.
5. Click **Run** to start the simulation.

---

## ğŸ§ª What Happens in Simulation?

* The **UVM Testbench** stimulates the DUT.
* A **monitor** collects the output signatures.
* A **scoreboard** compares the DUT outputs with the golden values.
* The comparison is done in the `check_phase()` of the scoreboard.
* Final results are printed showing:

  * How many values match
  * How many mismatched
  * Match percentage

---

## ğŸ§° Project Structure

```
bist_verification_project/
â”œâ”€â”€ rtl/                 # Verilog RTL design
â”œâ”€â”€ tb/                  # UVM testbench components
â”œâ”€â”€ model/                 # C++ code to generate golden values
â”‚   â”œâ”€â”€ golden_gen.cpp
â”‚   â””â”€â”€ Makefile
â”œâ”€â”€ golden_values/
â”‚   â””â”€â”€ golden_val_file.txt
â”œâ”€â”€ README.md            # This documentation file
```

---

## ğŸ›  Tools Used

* **SystemVerilog**
* **UVM (Universal Verification Methodology)**
* **EDA Playground**
* **C++**
* **Make / g++**

---

## ğŸ“Œ Summary

This project is a complete demonstration of a **Design Verification** flow using:

* Functional RTL Design
* C++ modeling of expected behavior
* UVM testbench setup with phases like `build`, `run`, `check`
* Scoreboard-driven result validation

---
